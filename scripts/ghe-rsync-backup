#!/usr/bin/env bash
#/ Usage: ghe-rsync-backup <host> <backup-dir>
#/ Take online, incremental snapshot of all Git repository data.
set -e

# Parse args
host="$1"
backup_dir="$2"

# Show usage if host or backup_dir not set
if [ -z "$host" -o -z "$backup_dir" ] || [ "$1" = "--help" ]; then
  grep '^#/' <"$0" | cut -c 4-
  exit 1
fi

# Local file locations
backup_dir=$(cd "$backup_dir" && pwd -P)
backup_date=$(date +"%Y%m%dT%H%M%S")
backup_current="$backup_dir/current"
backup_named="$backup_dir/$backup_date"

# Remote file locations
remote_repo_path="/data/repositories"
sync_in_progress_file="$remote_repo_path/.sync_in_progress"

# Verify rsync is available
if ! rsync --version 1>/dev/null 2>&1; then
    echo "Error: rsync not found." 1>&2
    exit 1
fi

# Verify ssh connectivity with the GHE host.
# TODO move this to use ghe-host-check instead. Should move all these nice
#      config / quick timeout options into that script.
if ! ssh -o PasswordAuthentication=no -o ConnectTimeout=5 -o ConnectionAttempts=1 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "$host" -- exit; then
    echo "Error: Couldn't connect to '$host' over ssh" 1>&2
    exit 1
fi

# Setup the basic directory structure when this is the first time we've
# performed a backup.
first_run=false
if [ ! -d "$backup_current" ]; then
  first_run=true
  mkdir -p "$backup_dir"
fi

# Cleans up the local rsync rules file and remote sync-in-progress file on exit.
cleanup() {
  rm -f repo_conf_sync_rules
  ssh "$host" -- "sudo -u git -- rm -f '$sync_in_progress_file'"
}
trap "cleanup" EXIT

# Touch the sync-in-progress file and wait for all active git-gc processes
# to finish on the remote side. This signals to the git-gc machinery
# that no objects or packs should be discarded for the duration of the backup
# run, which is required in order to perform a consistent online backup.
ssh "$host" -- "
    sudo -u git -- touch '$sync_in_progress_file'

    sanity=0
    while [ \$sanity -lt 60 ]; do
        if ps axo pid,args | grep -q git.g[c]; then
            sleep 1
            sanity=\$(( sanity + 1 ))
        else
            exit 0
        fi
    done
    exit 1
" || {
    echo "Error: git-gc processes remain after 60 seconds. Aborting..." 1>&2
    exit 1
}

build_rsync_cmd() {
  local default_opts="-azPrh --delete --rsync-path 'sudo -u git rsync'"
  local git_exclude="--exclude /*/*.git/*"
  local extra_excludes=$(enterprise_extra_excludes | xargs -n1 -IEXCLUDE echo --exclude EXCLUDE | xargs echo)
  local cmd_opts="$@ $git_exclude $extra_excludes"

  local rsync_cmd[0]="rsync"
  rsync_cmd+=("$default_opts")
  # use hardlinks if we can
  if [ -z "$first_run" ]; then
      rsync_cmd+=(--link-dest "$backup_current")
  fi

  rsync_cmd+=("$cmd_opts")
  rsync_cmd+=("$host:$remote_repo_path" "$backup_named")

  "${rsync_cmd[*]}"
}

enterprise_extra_excludes() {
  echo "__alambic_assets__ __gitmon__ __hookshot__ __nodeload_archives__ __purgatory__ __render__"
}

sync_configuration() {
  local sync_file="repo_conf_sync_rules"

  # setup base rules
  echo '+ *.git/conf' >> $sync_file
  echo '+ *.git/HEAD' >> $sync_file
  echo '+ *.git/audit_log' >> $sync_file
  echo '+ *.git/git-daemon-export-ok' >> $sync_file
  echo '+ *.git/logs/*' >> $sync_file
  echo '+ *.git/COMMIT_EDITMSG' >> $sync_file
  # exclude non-repo dirs
  enterprise_extra_excludes | xargs -n1 -IRULE echo "- RULE/" >> $sync_file
  echo '- *.git/*' >> $sync_file

  build_rsync_cmd '--filter' ". $sync_file"
}

sync_packed_refs() {
  build_rsync_cmd '--include' '/*/*.git/packed-refs'
}

sync_loose_refs() {
  build_rsync_cmd '--include' '/*/*.git/refs' '--include' '/*/*.git/logs/*'
}

sync_objects() {
  build_rsync_cmd '--include' '/*/*.git/objects' '--exclude' 'tmp_*'
}

update_current() {
  rm -f "$backup_current"
  ln -s "$backup_named" "$backup_current"
}

sync() {
  sync_configuration
  sync_loose_refs
  sync_packed_refs
  sync_objects
  update_current
}

sync
