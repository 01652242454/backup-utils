#!/usr/bin/env bash
#/ Usage: ghe-rsync-backup <host> <backup-dir>
#/ Take online, incremental snapshot of all Git repository data.
set -e

# Parse args
host="$1"
backup_dir="$2"

# Show usage if host or backup_dir not set
if [ -z "$host" -o -z "$backup_dir" ] || [ "$1" = "--help" ]; then
  grep '^#/' <"$0" | cut -c 4-
  exit 1
fi

# Local file locations
backup_dir=$(cd "$backup_dir" && pwd -P)
backup_date=$(date +"%Y%m%dT%H%M%S")
backup_name="$backup_date"

# Remote file locations
repo_path="/data/repositories"
sync_in_progress_file="$repo_path/.sync_in_progress"

# Verify rsync is available
if ! rsync --version 1>/dev/null 2>&1; then
    echo "Error: rsync not found." 1>&2
    exit 1
fi

# Verify ssh connectivity with the GHE host.
# TODO move this to use ghe-host-check instead. Should move all these nice
#      config / quick timeout options into that script.
if ! ssh -o PasswordAuthentication=no -o ConnectTimeout=5 -o ConnectionAttempts=1 -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null "$host" -- exit; then
    echo "Error: Couldn't connect to '$host' over ssh" 1>&2
    exit 1
fi

cleanup() {
  rm -f repo_conf_sync_rules
  cleanup_sync_in_progress_file
  exit $1
}

create_backup_structure() {
  mkdir -p "'$(printf '%s' "$backup_dir" | sed "s/'/\\\\''/g")'"
}

create_sync_in_progress_file() {
  ssh "$host" -- sudo -u git -- touch $sync_in_progress_file
}

cleanup_sync_in_progress_file() {
  ssh "$host" -- sudo -u git -- rm -f $sync_in_progress_file
}

wait_for_gc_to_die() {
  ssh "$host" -- '
    sanity=0
    while test "$sanity" -lt 60; do
        test -z "$(ps auxw | grep git.gc | grep -v grep)" && exit 0
        sleep 1
        sanity=$(($sanity+1))
    done
    exit 1
' || die "waited 60 seconds for gc-free state"
}

build_rsync_cmd() {
  local default_opts="-azPrh --delete --rsync-path 'sudo -u git rsync'"
  local git_exclude="--exclude /*/*.git/*"
  local extra_excludes=$(enterprise_extra_excludes | xargs -n1 -IEXCLUDE echo --exclude EXCLUDE | xargs echo)
  local cmd_opts="$@ $git_exclude $extra_excludes"

  local rsync_cmd[0]="rsync"
  rsync_cmd+=("$default_opts")
  # use hardlinks if we can
  if [ -z "$first_run" ]; then
      rsync_cmd+=(--link-dest "$(backup_current)")
  fi

  rsync_cmd+=("$cmd_opts")
  rsync_cmd+=("$host:$repo_path" "$(backup_named)")

  "${rsync_cmd[*]}"
}

backup_current() {
  echo "'$(printf '%s' "$backup_dir/current" | sed "s/'/\\\\''/g")'"
}

backup_named() {
  echo "'$(printf '%s' "$backup_dir/$backup_name" | sed "s/'/\\\\''/g")'"
}

enterprise_extra_excludes() {
  echo "__alambic_assets__ __gitmon__ __hookshot__ __nodeload_archives__ __purgatory__ __render__"
}

sync_configuration() {
  local sync_file="repo_conf_sync_rules"

  # setup base rules
  echo '+ *.git/conf' >> $sync_file
  echo '+ *.git/HEAD' >> $sync_file
  echo '+ *.git/audit_log' >> $sync_file
  echo '+ *.git/git-daemon-export-ok' >> $sync_file
  echo '+ *.git/logs/*' >> $sync_file
  echo '+ *.git/COMMIT_EDITMSG' >> $sync_file
  # exclude non-repo dirs
  enterprise_extra_excludes | xargs -n1 -IRULE echo "- RULE/" >> $sync_file
  echo '- *.git/*' >> $sync_file

  build_rsync_cmd '--filter' ". $sync_file"
}

sync_packed_refs() {
  build_rsync_cmd '--include' '/*/*.git/packed-refs'
}

sync_loose_refs() {
  build_rsync_cmd '--include' '/*/*.git/refs' '--include' '/*/*.git/logs/*'
}

sync_objects() {
  build_rsync_cmd '--include' '/*/*.git/objects' '--exclude' 'tmp_*'
}

update_current() {
  rm -f "$(backup_current)"
  ln -s "$(backup_named)" "$(backup_current)"
}

sync() {
  create_sync_in_progress_file
  wait_for_gc_to_die
  sync_configuration
  sync_loose_refs
  sync_packed_refs
  sync_objects
  update_current
}

if [ ! -d "$(backup_current)" ]; then
  first_run="1"
  create_backup_structure
fi

trap "cleanup" EXIT

sync
